# 阶段5 — 首页图片堆叠与尺寸不一致修复开发日志

**日期**：2026-02-26
**分支**：main
**涉及文件**：`Home.js` / `LiblibPromptCard.js` / `gallery.css`

---

## 一、问题描述

### Bug 1：首页图片全部堆叠（z轴重叠）

首页 "Latest Content" 区块的图片全部挤在同一位置，无法正常排列，视觉上完全错乱。

### Bug 2：首页图片尺寸与 Style Gallery 差异明显

修复堆叠后，首页卡片宽度约 **264px**，而 Style Gallery（Explore）页面卡片宽度约 **366px**，在同一显示器上差异肉眼可见。

---

## 二、根因分析

### Bug 1 根因 —— 多余的 `motion.div` 打断了 CSS Grid Masonry 链条

`.gallery-grid` 使用的是 **CSS Grid Masonry** 技术：

```css
.gallery-grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  grid-auto-rows: 8px;   /* 每行只有 8px */
  gap: 0 8px;
}
```

每张卡片必须通过 `style={{ gridRowEnd: 'span X' }}` 告诉 grid 自己要占多少行（X 由图片自然比例动态计算）。**关键约束：`gridRowEnd` 必须设置在 grid 的直接子元素上。**

**问题代码**（修复前 `Home.js`）：

```jsx
<div className="gallery-grid">
  {allPosts.map((post, index) => (
    <motion.div          {/* ← 这个 motion.div 才是 grid 的直接子元素 */}
      key={...}
      initial={...}
      animate={...}
      transition={...}
      {/* 没有 gridRowEnd！ */}
    >
      <LiblibStyleCard post={post} />   {/* gridRowEnd 在这里，但已是孙元素，无效 */}
    </motion.div>
  ))}
</div>
```

每个 `motion.div`（grid 直接子元素）没有 `gridRowEnd`，默认只占 `grid-auto-rows` 定义的 **8px**，导致所有卡片叠在 8px × n 的位置上，视觉上完全堆叠。

### Bug 2 根因 —— `home-section` 的 `max-width: 1400px` 限制了网格宽度

```css
/* 修复前 */
.home-section {
  max-width: 1400px;    /* 首页内容区被锁在 1400px */
  margin: 0 auto;
  padding: 0 1.5rem;
}

.home-content-section {
  margin-bottom: 0;     /* 没有覆盖 max-width */
}
```

而 Gallery / Explore 页面使用 `.gallery-page { width: 100% }`，无 max-width 限制。

在 2134px 宽的显示器上：

| 页面 | 网格有效宽度 | 列数 | 每列宽度 |
|------|-----------|------|---------|
| 首页（修复前） | 1400px - 48px = **1352px** | 5 | **264px** |
| Explore（有 sidebar） | 2134px - 24px - 248px = **1862px** | 5 | **366px** |
| 首页（修复后） | 2134px - 24px = **2110px** | 5 | **415px** |

### Bug 3 根因（次要）—— `LiblibPromptCard` 完全缺失 `gridRowEnd` 逻辑

`LiblibStyleCard` 已有完整的 span 计算逻辑，但 `LiblibPromptCard` 的 `motion.div` 上既没有 `ref`，也没有 `gridRowEnd`，导致 Prompt 卡片在 gallery-grid 中始终只有 8px 高度。

---

## 三、修复方案

### Fix 1 — `Home.js`：移除多余的 `motion.div` 包装层

**原则**：`LiblibStyleCard` 和 `LiblibPromptCard` 内部都已有自己的 `motion.div`（含 enter 动画），不需要外层再包。

```jsx
/* 修复前 */
<div className="gallery-grid">
  {allPosts.map((post, index) => (
    <motion.div key={...} initial={...} animate={...} transition={...}>
      {post.contentType === 'prompt'
        ? <LiblibPromptCard prompt={post} />
        : <LiblibStyleCard post={post} />}
    </motion.div>
  ))}
</div>

/* 修复后 */
<div className="gallery-grid">
  {allPosts.map((post) => (
    post.contentType === 'prompt'
      ? <LiblibPromptCard key={`prompt-${post._id}`} prompt={post} />
      : <LiblibStyleCard key={`style-${post._id}`} post={post} />
  ))}
</div>
```

同时移除了 `Home.js` 中已无用的 `import { motion } from 'framer-motion'`。

### Fix 2 — `LiblibPromptCard.js`：补充完整的 gridRowEnd span 计算

完全镜像 `LiblibStyleCard` 和 `GalleryCard` 的模式：

```js
const ROW_HEIGHT = 8; // 必须与 gallery.css grid-auto-rows 一致
const ROW_GAP = 8;

// 新增 ref 和 span state
const cardRef = useRef(null);
const [gridSpan, setGridSpan] = useState(38); // 初始值 ≈ 300px 预留高度
const naturalSize = useRef(null);

// 按图片自然比例 + 当前列宽计算 span
const calcSpan = useCallback((colWidth) => {
  const { w, h } = naturalSize.current || {};
  if (w > 0 && h > 0 && colWidth > 0) {
    const renderedH = Math.round((h / w) * colWidth);
    setGridSpan(Math.ceil((renderedH + ROW_GAP) / ROW_HEIGHT));
  }
}, []);

// ResizeObserver：列宽变化时（窗口缩放、sidebar 开关）自动重算
useEffect(() => {
  if (!cardRef.current) return;
  const ro = new ResizeObserver((entries) => {
    const colWidth = entries[0]?.contentRect?.width;
    if (colWidth && naturalSize.current) calcSpan(colWidth);
  });
  ro.observe(cardRef.current);
  return () => ro.disconnect();
}, [calcSpan]);

// 图片加载完成后获取自然尺寸，首次计算 span
const handleImageLoad = (e) => {
  const img = e.currentTarget;
  if (img && cardRef.current) {
    const w = img.naturalWidth;
    const h = img.naturalHeight;
    if (w > 0 && h > 0) {
      naturalSize.current = { w, h };
      calcSpan(cardRef.current.offsetWidth);
    }
  }
};
```

在根元素上应用：
```jsx
<motion.div
  ref={cardRef}
  style={{ gridRowEnd: `span ${gridSpan}` }}   {/* ← 关键 */}
  className="liblib-prompt-card"
  ...
>
```

### Fix 3 — `gallery.css`：`.home-content-section` 突破 max-width 限制

```css
/* 修复前 */
.home-content-section {
  margin-bottom: 0;
}

/* 修复后 */
.home-content-section {
  max-width: none;      /* 覆盖 .home-section 的 1400px 限制 */
  margin-left: 0;
  margin-right: 0;
  margin-bottom: 0;
  padding: 0 0.75rem;  /* 与 gallery-page 对齐 */
}
```

---

## 四、修改文件清单

| 文件 | 改动类型 | 说明 |
|------|---------|------|
| `client/src/pages/Home.js` | MODIFY | 移除多余 motion.div 包装；删除无用 framer-motion import |
| `client/src/components/Prompt/LiblibPromptCard.js` | MODIFY | 新增 gridRowEnd span 计算逻辑（useRef/useEffect/useCallback/ResizeObserver） |
| `client/src/styles/gallery.css` | MODIFY | `.home-content-section` 追加 max-width: none 覆盖规则 |

---

## 五、验证结果

| 指标 | 修复前 | 修复后 |
|------|-------|-------|
| 首页图片堆叠 | ❌ 全部叠在一起 | ✅ 正常瀑布流排列 |
| 首页卡片宽度（2134px viewport） | 264px | 415px |
| Explore 卡片宽度（含 sidebar） | 366px | 366px（不变） |
| 宽度差异 | **102px（差 28%）** | **49px（差 12%，差值来自 sidebar，合理）** |
| LiblibPromptCard 高度 | 固定 8px（堆叠） | ✅ 按图片自然比例动态计算 |

---

## 六、关于首页图片"方方正正"的外观说明

修复后首页图片整体看起来高度较为一致（每行看起来差不多高），这**不是 bug**。原因：

- CSS Grid Masonry 是正确工作的，每张图片按自然比例展示
- 当前数据库中的图片以**横版 16:9 / 4:3** 为主，宽高比接近
- 随着更多竖版图片（人像、纵向构图）导入，瀑布流的高低差异会自然呈现
- 如需强制更多视觉层次感，可考虑减少列数（3列 → 每列更宽，对比更强烈）

---

## 七、技术经验总结

### 经验 1：CSS Grid Masonry 的直接子元素规则（本次 Bug 核心）

`gridRowEnd: span X` 只对 **grid 容器的直接子元素** 有效。在 React 中，如果在卡片外面套了任何 wrapper（哪怕是 `motion.div`），该 wrapper 成为直接子元素，内层卡片的 `gridRowEnd` 完全失效。

**检查方法**：DevTools → Elements → 选中 `.gallery-grid` → 看 "grid" 标识，子元素是否有橙色 span 标记。

### 经验 2：卡片组件应自包含动画，不依赖外层 wrapper

`LiblibStyleCard` 和 `LiblibPromptCard` 自带 `motion.div` 动画，不需要页面层再套 `motion.div`。页面层负责 key 和布局，卡片层负责动画和交互。

### 经验 3：`max-width` 在嵌套容器中的层级穿透

子容器的 `max-width` 即使移除，父容器的 `max-width` 仍然约束布局。必须在正确层级（本例是 `.home-content-section`）用 `max-width: none` 显式覆盖。

### 经验 4：ResizeObserver 是 span 计算的必要保险

图片加载时计算一次 span 不够——用户调整窗口大小、切换 sidebar 开关都会改变列宽。ResizeObserver 监听卡片宽度变化，自动重算 `gridSpan`，保证始终正确。
